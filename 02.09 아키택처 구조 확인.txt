1️⃣CommandManger 비대화 경계선 그리기

Q1. CommandManager가 알아도 되는 것 3가지

1. 어떤 Command가 현재 실행 중인지
→ 시스템 흐름을 제어하기 위해 필요

2. Command 실행의 순서와 중단 여부
→ 큐 관리와 위험 제어는 Manager의 책임

3. STOP·중단 같은 시스템 레벨 개입 조건
→ 장비 보호를 위한 최종 판단 주체이기 때문

-------------------------------------------
Q2. CommandManager가 알면 위험해지는 것 3가지

1. Command의 성공 조건이나 내부 판단 로직
→ 정책과 실행이 결합되기 시작함

2. 망원경의 물리적 동작 방식(좌표 계산, 속도 등)
→ 하드웨어 세부사항에 종속됨

3. 각 Command가 왜 실패했는지에 대한 세부 이유
→ 책임이 Command에서 Manager로 이동해 버림

-------------------------------------------
2️⃣STOP → EMERGENCY_STOP / SOFT_STOP 분화

① 가장 먼저 깨지는 곳
CommandManager의 판단 책임

지금 구조에서 STOP은: “조건 없이, 즉시, 전부 중단”

그런데 STOP이 둘로 나뉘는 순간:
● EMERGENCY_STOP → 무조건 즉시 정지
● SOFT_STOP → 현재 Command는 마무리 허용

“어디까지 끊을지”를 결정해야 하는 주체가 필요

이 판단이 들어오는 순간
CommandManager는 ‘조정자’에서 ‘정책 결정자’로 변질되기 시작
----------------------------------------------------------------
② 그 다음으로 깨지는 곳
Command의 순수성

STOP 종류가 생기면, 유혹이 생깁니다: 
● “MOVE는 SOFT_STOP이면 끝까지 가도 되지 않나?”
● “TRACK는 EMERGENCY_STOP에서만 멈추게 할까?”

이 생각이 코드에 들어가는 순간:
Command가 자기 임무 + 시스템 중단 정책을 동시에 알게 됨
무엇을 할지뿐 아니라 언제 멈춰도 되는지를 판단하기 시작함

이건 구조 붕괴의 시작 신호
---------------------------------------------------------------
③ 가장 늦게, 하지만 치명적으로 깨지는 곳
STOP의 개념적 정체성

지금 STOP은: 명령(Command)이 아니라 외부 개입(Interrupt)

종류가 늘어나면:
● STOP이 “상태를 가진다”
● STOP이 “조건을 가진다”
● STOP이 “성공/실패를 논하게 된다”

STOP은 Command처럼 보이기 시작하지만, 실제로는 더 위험한 존재

왜냐하면:
● 큐에 들어가면 안 되는데
● 우선순위도 있고
● 다른 Command의 생명주기를 좌우하기 때문입니다

--------------------------------------------------------------
3️⃣ 로그 책임 재확인 (개념 정리) 아래를 한 문장씩 정리
1. Command 로그는 무엇을 남겨야 하는가?
A: “이 Command가 어떤 의도로 시작되었고, 어떤 상태로 끝났는가”만 남겨야 한다.
2. Manager 로그는 무엇을 남겨야 하는가?
A: “왜 이 Command를 실행했고, 왜 이 흐름을 중단·변경했는가”를 남겨야 한다.
3. State 로그는 언제 찍혀야 하는가?
A: 외부 관찰자가 시스템의 상태가 바뀌었다고 인식해야 하는 순간에만 찍혀야 한다.

-----------------------------------------------------------
02.10 다중흐름을 위한 사전 작업

1️⃣ 다중 장비로 가면 가장 먼저 바뀌는 것
❌ 바뀌면 안 되는 것

Command의 개념

Command의 생명주기

STOP의 정체성 (interrupt)

CommandManager의 역할 정의

👉 이건 절대 건드리면 안 됩니다.
-------------------------------------
✅ 바뀌어야 하는 것 (핵심)
① “CommandManager는 장비를 직접 소유하면 안 된다”

지금은 개념적으로:

CommandManager
 └── telescope (1대)


다중 장비에서는 이게 위험해집니다.

대신 구조적으로 이렇게 가야 합니다:

SystemController (or Scheduler)
 ├── Telescope A
 │    └── CommandManager A
 ├── Telescope B
 │    └── CommandManager B


✔ CommandManager = 장비 1대의 실행 흐름 책임자
✔ 장비 수만큼 Manager가 생김

-------------------------------------------------
각 Telescope는 자기 CommandManager를 가지고, 상위 컨트롤러(SystemController)는 장비 간 정책만 담당한다.

---------------------------------------------------
| 구성요소          | 책임              |
| ---------------- | --------------- |
| Command          | 단일 행동의 시간 기반 실행 |
| CommandManager   | 장비 1대의 실행 흐름    |
| Telescope        | 물리 상태           |
| SystemController | 장비 간 정책, 글로벌 개입 |
-----------------------------------------------------
절대 하지 말아햐 할 것

1. 하나의 CommandManager가 여러 Telescope를 직접 제어하지 않는다

2. Command가 다른 장비의 상태를 보지 않는다

3. 글로벌 STOP을 Command로 만들지 않는다

---------------------------------------------------
Day 37 통과 기준
1. 왜 Telescope마다 CommandManager가 있어야 하는가?
A: 흐름은 장비에 종속된 개념이기 때문에, 하나의 CommandManager가 여러 Telescope를 관리하면 서로 다른 시간축의 흐름이 하나의 판단 단위로 섞이게 된다.

2. 다중 장비에서 STOP은 왜 더 위험해지는가?
A: STOP은 ‘무엇을 멈출 것인가’를 반드시 동반하는 개입인데, 다중 장비 환경에서는 그 범위가 명시되지 않으면 개입의 영향이 예측 불가능해진다.
    그래서 STOP은 Command가 아니라 적용 범위를 아는 상위 레벨(SystemController)의 책임이다.

3. “흐름”은 어디에 속한 개념인가?
A: CommandManager에 속한 개념

-------------------------------------------------
Day 38 다중 흐름시의 로그 설계

Q1. SystemController는 무엇을 가져야 하는가?
A: CommandManager목록, 전역 정책 권한, 전체 STOP 권한, 장비간 정책 판단 [흐름들 사이의 정책만 다룸]

Q2. 전역 STOP이 들어오면:
A: SystemController → 각 CommandManager에게 STOP 신호 전달 → 각 Manager가 자기 Telescope를 정지

Q3. 다중 장비에서 가장 위험한 결합은 어디인가?
A:  1. 전역 시간축 공유 : 모든 장비가 하나의 update 루프에 종속되면 한 장비 지연이 전체 지연 됨
    2. 공용 queue : 장비 A의 Command가 장비 B 흐름에 개입 되면 흐름 단위가 붕괴
    3. 공용 stop 객체 : stop 범위가 모호

[day 38이어서-------------------------------]
로그 시뮬레이션
[A][CMD] MoveCommand START
[A][STATE] IDLE → MOVING

[B][CMD] MoveCommand START
[B][STATE] IDLE → MOVING

[A][SYSTEM] STOP triggered (local)
[A][STATE] MOVING → STOPPED

[B][UPDATE] MOVING Alt=12.3 Az=12.3

[A]라는 식별자는 telescope또는 대응하는 CommandManager가 붙인다

STOP이 A에만 적용되도록 A의 CommandManager가 보장

로그가 섞이지 않으려면 실행흐름, 상태 전이 책임, stop 범위가 분리되어야 한다.
---------------------------------------------------
Day 39 SystemController구조 정의
SystemController는 telescope를 모른다 
manager만 안다 
STOP을 직접 수행하지 않는다 
“전달”만 한다
-----------------------------------
STOP 계층 구조 정리 정리: 
Local STOP → Manager 책임 
Global STOP → SystemController 책임 
실제 물리 정지 → Telescope 책임 
이 3단 분리는 절대 깨지면 안됨
---------------------------
1. SystemController는 왜 Telescope를 직접 알면 안 되는가? 
A: SystemController는 정책계층이고, telescope는 물리계층이기 때문
    흐름은 Manager의 소유이기 때문에 건너뛰면 구조 붕괴
2. 왜 Command를 직접 실행하면 안 되는가? 
A: Command 실행은 흐름의 일부, 흐름은 Manager의 책임
    SystemController
    ↓ (정책 전달)
    CommandManager
    ↓ (흐름 제어)
    Command
3. global_stop()은 왜 직접 멈추지 않고 “전달”만 하는가?
A: STOP의 실제 실행은 흐름을 소유한 계층만 할 수 있기 때문
    SystemController는 권한을 행사하지만, 행동은 하지 않는다

-----------
day 40
1. SystemController가 상태를 가지기 시작하면, 어떤 계층이 가장 먼저 위험해질까?
A: CommandManager
    SystemController가 상태를 가지는 순간 정책이 실행을 직접 통제하기 시작하는 것이기 때문에 흐름 계층인 CommandManager가 위험

2. 전역 상태가 생기면 STOP의 정체성은 유지될까, 변질될까?
A: 변질됨
    SYSTEM_EMERGENCY 상태 → 모든 Manager 강제 차단 → Command 실행 금지 → update 차단 이렇게 되면 암묵적 정책 효과가 된다

3. 지금 단계에서 Global State Machine을 넣는 건 “설계 강화”일까, “설계 조급증”일까?
A: 설계 조급증이 아닐까?