1️⃣CommandManger 비대화 경계선 그리기

Q1. CommandManager가 알아도 되는 것 3가지

1. 어떤 Command가 현재 실행 중인지
→ 시스템 흐름을 제어하기 위해 필요

2. Command 실행의 순서와 중단 여부
→ 큐 관리와 위험 제어는 Manager의 책임

3. STOP·중단 같은 시스템 레벨 개입 조건
→ 장비 보호를 위한 최종 판단 주체이기 때문

-------------------------------------------
Q2. CommandManager가 알면 위험해지는 것 3가지

1. Command의 성공 조건이나 내부 판단 로직
→ 정책과 실행이 결합되기 시작함

2. 망원경의 물리적 동작 방식(좌표 계산, 속도 등)
→ 하드웨어 세부사항에 종속됨

3. 각 Command가 왜 실패했는지에 대한 세부 이유
→ 책임이 Command에서 Manager로 이동해 버림

-------------------------------------------
2️⃣STOP → EMERGENCY_STOP / SOFT_STOP 분화

① 가장 먼저 깨지는 곳
CommandManager의 판단 책임

지금 구조에서 STOP은: “조건 없이, 즉시, 전부 중단”

그런데 STOP이 둘로 나뉘는 순간:
● EMERGENCY_STOP → 무조건 즉시 정지
● SOFT_STOP → 현재 Command는 마무리 허용

“어디까지 끊을지”를 결정해야 하는 주체가 필요

이 판단이 들어오는 순간
CommandManager는 ‘조정자’에서 ‘정책 결정자’로 변질되기 시작
----------------------------------------------------------------
② 그 다음으로 깨지는 곳
Command의 순수성

STOP 종류가 생기면, 유혹이 생깁니다: 
● “MOVE는 SOFT_STOP이면 끝까지 가도 되지 않나?”
● “TRACK는 EMERGENCY_STOP에서만 멈추게 할까?”

이 생각이 코드에 들어가는 순간:
Command가 자기 임무 + 시스템 중단 정책을 동시에 알게 됨
무엇을 할지뿐 아니라 언제 멈춰도 되는지를 판단하기 시작함

이건 구조 붕괴의 시작 신호
---------------------------------------------------------------
③ 가장 늦게, 하지만 치명적으로 깨지는 곳
STOP의 개념적 정체성

지금 STOP은: 명령(Command)이 아니라 외부 개입(Interrupt)

종류가 늘어나면:
● STOP이 “상태를 가진다”
● STOP이 “조건을 가진다”
● STOP이 “성공/실패를 논하게 된다”

STOP은 Command처럼 보이기 시작하지만, 실제로는 더 위험한 존재

왜냐하면:
● 큐에 들어가면 안 되는데
● 우선순위도 있고
● 다른 Command의 생명주기를 좌우하기 때문입니다

--------------------------------------------------------------
3️⃣ 로그 책임 재확인 (개념 정리) 아래를 한 문장씩 정리
1. Command 로그는 무엇을 남겨야 하는가?
A: “이 Command가 어떤 의도로 시작되었고, 어떤 상태로 끝났는가”만 남겨야 한다.
2. Manager 로그는 무엇을 남겨야 하는가?
A: “왜 이 Command를 실행했고, 왜 이 흐름을 중단·변경했는가”를 남겨야 한다.
3. State 로그는 언제 찍혀야 하는가?
A: 외부 관찰자가 시스템의 상태가 바뀌었다고 인식해야 하는 순간에만 찍혀야 한다.