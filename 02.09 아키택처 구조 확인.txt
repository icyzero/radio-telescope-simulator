1️⃣CommandManger 비대화 경계선 그리기

Q1. CommandManager가 알아도 되는 것 3가지

1. 어떤 Command가 현재 실행 중인지
→ 시스템 흐름을 제어하기 위해 필요

2. Command 실행의 순서와 중단 여부
→ 큐 관리와 위험 제어는 Manager의 책임

3. STOP·중단 같은 시스템 레벨 개입 조건
→ 장비 보호를 위한 최종 판단 주체이기 때문

-------------------------------------------
Q2. CommandManager가 알면 위험해지는 것 3가지

1. Command의 성공 조건이나 내부 판단 로직
→ 정책과 실행이 결합되기 시작함

2. 망원경의 물리적 동작 방식(좌표 계산, 속도 등)
→ 하드웨어 세부사항에 종속됨

3. 각 Command가 왜 실패했는지에 대한 세부 이유
→ 책임이 Command에서 Manager로 이동해 버림

-------------------------------------------
2️⃣STOP → EMERGENCY_STOP / SOFT_STOP 분화

① 가장 먼저 깨지는 곳
CommandManager의 판단 책임

지금 구조에서 STOP은: “조건 없이, 즉시, 전부 중단”

그런데 STOP이 둘로 나뉘는 순간:
● EMERGENCY_STOP → 무조건 즉시 정지
● SOFT_STOP → 현재 Command는 마무리 허용

“어디까지 끊을지”를 결정해야 하는 주체가 필요

이 판단이 들어오는 순간
CommandManager는 ‘조정자’에서 ‘정책 결정자’로 변질되기 시작
----------------------------------------------------------------
② 그 다음으로 깨지는 곳
Command의 순수성

STOP 종류가 생기면, 유혹이 생깁니다: 
● “MOVE는 SOFT_STOP이면 끝까지 가도 되지 않나?”
● “TRACK는 EMERGENCY_STOP에서만 멈추게 할까?”

이 생각이 코드에 들어가는 순간:
Command가 자기 임무 + 시스템 중단 정책을 동시에 알게 됨
무엇을 할지뿐 아니라 언제 멈춰도 되는지를 판단하기 시작함

이건 구조 붕괴의 시작 신호
---------------------------------------------------------------
③ 가장 늦게, 하지만 치명적으로 깨지는 곳
STOP의 개념적 정체성

지금 STOP은: 명령(Command)이 아니라 외부 개입(Interrupt)

종류가 늘어나면:
● STOP이 “상태를 가진다”
● STOP이 “조건을 가진다”
● STOP이 “성공/실패를 논하게 된다”

STOP은 Command처럼 보이기 시작하지만, 실제로는 더 위험한 존재

왜냐하면:
● 큐에 들어가면 안 되는데
● 우선순위도 있고
● 다른 Command의 생명주기를 좌우하기 때문입니다

--------------------------------------------------------------
3️⃣ 로그 책임 재확인 (개념 정리) 아래를 한 문장씩 정리
1. Command 로그는 무엇을 남겨야 하는가?
A: “이 Command가 어떤 의도로 시작되었고, 어떤 상태로 끝났는가”만 남겨야 한다.
2. Manager 로그는 무엇을 남겨야 하는가?
A: “왜 이 Command를 실행했고, 왜 이 흐름을 중단·변경했는가”를 남겨야 한다.
3. State 로그는 언제 찍혀야 하는가?
A: 외부 관찰자가 시스템의 상태가 바뀌었다고 인식해야 하는 순간에만 찍혀야 한다.

-----------------------------------------------------------
02.10 다중흐름을 위한 사전 작업

1️⃣ 다중 장비로 가면 가장 먼저 바뀌는 것
❌ 바뀌면 안 되는 것

Command의 개념

Command의 생명주기

STOP의 정체성 (interrupt)

CommandManager의 역할 정의

👉 이건 절대 건드리면 안 됩니다.
-------------------------------------
✅ 바뀌어야 하는 것 (핵심)
① “CommandManager는 장비를 직접 소유하면 안 된다”

지금은 개념적으로:

CommandManager
 └── telescope (1대)


다중 장비에서는 이게 위험해집니다.

대신 구조적으로 이렇게 가야 합니다:

SystemController (or Scheduler)
 ├── Telescope A
 │    └── CommandManager A
 ├── Telescope B
 │    └── CommandManager B


✔ CommandManager = 장비 1대의 실행 흐름 책임자
✔ 장비 수만큼 Manager가 생김

-------------------------------------------------
각 Telescope는 자기 CommandManager를 가지고, 상위 컨트롤러(SystemController)는 장비 간 정책만 담당한다.

---------------------------------------------------
| 구성요소          | 책임              |
| ---------------- | --------------- |
| Command          | 단일 행동의 시간 기반 실행 |
| CommandManager   | 장비 1대의 실행 흐름    |
| Telescope        | 물리 상태           |
| SystemController | 장비 간 정책, 글로벌 개입 |
-----------------------------------------------------
절대 하지 말아햐 할 것

1. 하나의 CommandManager가 여러 Telescope를 직접 제어하지 않는다

2. Command가 다른 장비의 상태를 보지 않는다

3. 글로벌 STOP을 Command로 만들지 않는다

---------------------------------------------------
Day 37 통과 기준
1. 왜 Telescope마다 CommandManager가 있어야 하는가?
A: 흐름은 장비에 종속된 개념이기 때문에, 하나의 CommandManager가 여러 Telescope를 관리하면 서로 다른 시간축의 흐름이 하나의 판단 단위로 섞이게 된다.

2. 다중 장비에서 STOP은 왜 더 위험해지는가?
A: STOP은 ‘무엇을 멈출 것인가’를 반드시 동반하는 개입인데, 다중 장비 환경에서는 그 범위가 명시되지 않으면 개입의 영향이 예측 불가능해진다.
    그래서 STOP은 Command가 아니라 적용 범위를 아는 상위 레벨(SystemController)의 책임이다.

3. “흐름”은 어디에 속한 개념인가?
A: CommandManager에 속한 개념